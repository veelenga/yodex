{
  "id": "typescript",
  "name": "TypeScript",
  "slug": "typescript-interview-questions",
  "category": "Languages",
  "totalQuestions": 15,
  "topics": [
    "advanced",
    "basics",
    "performance",
    "testing"
  ],
  "questions": [
    {
      "id": 1,
      "question": "What is _TypeScript_ and how does it differ from _JavaScript_?",
      "options": [
        "TypeScript is an alternative JavaScript runtime environment that provides enhanced type checking and compilation mechanisms for web applications.",
        "TypeScript is a statically-typed superset of JavaScript developed by Microsoft, which adds optional type annotations and compiles to standard JavaScript, enabling enhanced code maintainability and predictability.",
        "TypeScript is a client-side framework developed by Google to provide advanced JavaScript compilation techniques and improved runtime performance.",
        "TypeScript is a completely new programming language designed to replace JavaScript, offering a more rigid and complex syntax for web development implementations."
      ],
      "correctIndex": 1,
      "explanation": "TypeScript extends JavaScript by introducing optional static typing, which helps developers catch type-related errors during development. By compiling to standard JavaScript, it ensures broad compatibility with existing web technologies. The type system allows developers to add type annotations that provide compile-time type checking without affecting runtime behavior.\n\nExample of TypeScript type annotation:\n```typescript\nfunction greet(name: string): string {\n  return `Hello, ${name}!`;\n}\n```"
    },
    {
      "id": 2,
      "question": "Can you explain what is meant by \"_TypeScript_ is a _superset_ of _JavaScript_\"?",
      "options": [
        "A superset in TypeScript means that it completely replaces JavaScript syntax and requires developers to rewrite all existing JavaScript code to be compatible with TypeScript.",
        "Being a superset indicates that TypeScript automatically transforms all JavaScript code into a more performant and type-safe version during runtime.",
        "When TypeScript is described as a superset of JavaScript, it means that all valid JavaScript code is also valid TypeScript code, allowing seamless integration and gradual adoption of TypeScript features.",
        "A superset implies that TypeScript is a strict replacement for JavaScript that enforces mandatory type annotations and compilation for all web projects."
      ],
      "correctIndex": 2,
      "explanation": "The superset concept in TypeScript allows developers to incrementally adopt TypeScript in existing JavaScript projects. This means you can rename .js files to .ts and start adding type annotations without breaking existing code. The TypeScript compiler will transpile the code to standard JavaScript while providing additional type checking.\n\nExample of gradual TypeScript adoption:\n```typescript\n// Valid JavaScript and TypeScript\nfunction add(a, b) {\n  return a + b;\n}\n\n// Enhanced with TypeScript types\nfunction typedAdd(a: number, b: number): number {\n  return a + b;\n}\n```"
    },
    {
      "id": 3,
      "question": "What are the _basic types_ available in _TypeScript_?",
      "options": [
        "TypeScript supports only strongly typed primitive types that must be explicitly declared and cannot be dynamically changed during runtime.",
        "TypeScript basic types include complex data structures like objects, maps, and custom class-based types that replace traditional JavaScript primitive types.",
        "TypeScript provides several basic types including boolean (true/false), number (integers and floats), string (text), array (list of elements), and tuple (fixed-length array with potentially different element types).",
        "The basic types in TypeScript are limited to primitive mathematical representations and do not support complex data manipulation or type inference."
      ],
      "correctIndex": 2,
      "explanation": "TypeScript's type system provides type safety while maintaining JavaScript's flexibility. Basic types help catch potential errors during development and improve code documentation. Types can be explicitly declared or inferred by the compiler.\n\nExample of TypeScript basic types:\n```typescript\n// Boolean\nlet isActive: boolean = true;\n\n// Number\nlet count: number = 42;\n\n// String\nlet message: string = 'Hello';\n\n// Array\nlet numbers: number[] = [1, 2, 3];\n\n// Tuple\nlet record: [string, number] = ['User', 123];\n```"
    },
    {
      "id": 4,
      "question": "How do you declare _variables_ in _TypeScript_?",
      "options": [
        "In TypeScript, variables can be declared using 'var', 'let', and 'const', with 'let' being the recommended modern approach for block-scoped variables that provide better type safety and control.",
        "TypeScript supports variable declarations through a unique compilation process that translates type annotations into runtime type checking mechanisms.",
        "Variable declarations in TypeScript rely exclusively on the 'var' keyword, which provides comprehensive type inference and global accessibility for all variable types.",
        "TypeScript variables are always dynamically typed and can be declared using global scope declarations that automatically convert between different data types."
      ],
      "correctIndex": 0,
      "explanation": "TypeScript provides multiple ways to declare variables with type annotations. The 'let' keyword is preferred over 'var' because it prevents hoisting and provides block-level scoping, which reduces potential errors. Type annotations can be explicitly defined to ensure type safety."
    },
    {
      "id": 5,
      "question": "What are _Interfaces_ in _TypeScript_ and how do they work?",
      "options": [
        "TypeScript interfaces serve as abstract base classes that provide default implementation strategies for creating type-safe object prototypes and inheritance patterns.",
        "Interfaces in TypeScript are runtime objects that generate dynamic type checking mechanisms for validating complex object interactions during program execution.",
        "Interfaces in TypeScript define a contract for object structures, specifying the required properties and methods that implementing classes or objects must adhere to, ensuring type consistency and code reliability.",
        "Interfaces represent a compilation-time mechanism for generating type metadata that enables advanced reflection and runtime type transformation capabilities."
      ],
      "correctIndex": 2,
      "explanation": "Interfaces are a powerful TypeScript feature that allows developers to define structural types. They act as a blueprint for object shapes, enabling compile-time type checking without introducing runtime overhead."
    },
    {
      "id": 6,
      "question": "Describe the _Enum_ type and when you might use it.",
      "options": [
        "Enums represent a compilation strategy for creating bidirectional mapping between numeric and string-based constant representations in strongly typed environments.",
        "Enums are runtime-based data structures that dynamically generate type conversion mechanisms for managing complex value transformations during program execution.",
        "Enums in TypeScript are type-safe ways to define a set of named constants, providing a structured approach to representing discrete values and improving code readability and maintainability.",
        "TypeScript enums serve as advanced reflection tools that enable complex type inference and automatic code generation for multiple value mappings."
      ],
      "correctIndex": 2,
      "explanation": "Enums allow developers to create a set of named constants, making code more readable and type-safe. They can be numeric or string-based, and TypeScript generates an efficient mapping between names and values."
    },
    {
      "id": 7,
      "question": "How do you define and use a _function_ in _TypeScript_?",
      "options": [
        "TypeScript functions are created by implementing interface method signatures, which require comprehensive type definitions and cannot be used without a predefined interface contract.",
        "Functions in TypeScript are primarily defined using class methods and must always include a mandatory type annotation for both input and output to ensure strict type checking.",
        "TypeScript functions are always declared using the 'function' keyword and require explicit type declarations for every parameter and return value, making them more rigid than JavaScript functions.",
        "In TypeScript, functions are defined using a function signature that includes the function name, parameter types, and return type. Functions can be declared using function syntax or as arrow functions, with explicit type annotations for clarity."
      ],
      "correctIndex": 3,
      "explanation": "TypeScript provides flexible function definitions with strong type support. Functions can be defined using traditional function syntax or arrow function notation, with optional type annotations. The type system helps catch errors during development and provides better code documentation."
    },
    {
      "id": 8,
      "question": "What does \"_type inference_\" mean in the context of _TypeScript_?",
      "options": [
        "TypeScript's type inference mechanism requires complex type mapping rules that manually track and predict variable type transformations during code compilation.",
        "Type inference is a compilation technique that forces developers to explicitly declare every possible type variation for variables to ensure maximum type compatibility.",
        "Type inference in TypeScript automatically determines variable types based on their initial value, allowing the compiler to deduce types without explicit type annotations while maintaining type safety.",
        "Type inference in TypeScript is a process where the compiler randomly assigns types to variables based on their initial context, potentially leading to unpredictable type assignments."
      ],
      "correctIndex": 2,
      "explanation": "Type inference is a powerful TypeScript feature that automatically determines variable types, reducing the need for verbose type declarations. It analyzes the assigned value and context to determine the most appropriate type, enhancing code readability and maintainability."
    },
    {
      "id": 9,
      "question": "Explain the use of '_let_' and '_const_' in _TypeScript_.",
      "options": [
        "'let' and 'const' are TypeScript keywords that introduce strict scoping rules, requiring explicit type annotations and preventing any form of variable mutation or reassignment.",
        "The 'let' and 'const' declarations in TypeScript enforce compile-time type locking, preventing any dynamic type changes or value reassignments throughout the code execution.",
        "'let' and 'const' in TypeScript provide block-scoped variable declarations, with 'const' creating immutable references and 'let' allowing variable reassignment within the same scope.",
        "In TypeScript, 'let' and 'const' are used to create global variables with enhanced type checking, ensuring that variables cannot be modified outside their initial declaration context."
      ],
      "correctIndex": 2,
      "explanation": "TypeScript adopts JavaScript's 'let' and 'const' declarations, providing block-scoped variables with improved type safety. 'const' prevents reassignment of the variable reference, while 'let' allows dynamic reassignment within the same scope."
    },
    {
      "id": 10,
      "question": "How do you compile _TypeScript_ files into _JavaScript_?",
      "options": [
        "TypeScript files are compiled using Node.js runtime with a built-in transpilation mechanism that converts TypeScript syntax to JavaScript on-the-fly.",
        "Compile TypeScript by using Babel with a special TypeScript preset that transforms .ts files directly into browser-compatible JavaScript automatically.",
        "To compile TypeScript files into JavaScript, use the TypeScript compiler (tsc) by running the command `tsc filename.ts` or configure a `tsconfig.json` file for more advanced compilation options.",
        "Compilation happens through Visual Studio Code's integrated compiler, which automatically generates JavaScript files when you save a TypeScript document."
      ],
      "correctIndex": 2,
      "explanation": "The TypeScript compiler (tsc) is the standard tool for converting TypeScript files to JavaScript. It provides type checking, syntax validation, and generates clean JavaScript output. Configuration can be customized using tsconfig.json, which allows developers to specify compilation targets, module systems, and other build preferences. A typical compilation might look like this:\n\n```typescript\n// tsconfig.json example\n{\n  \"compilerOptions\": {\n    \"target\": \"es5\",\n    \"module\": \"commonjs\"\n  }\n}\n\n// Compile with\n// tsc or tsc filename.ts\n```"
    },
    {
      "id": 11,
      "question": "Explain _classes_ in _TypeScript_. How are they different from _ES6 classes_?",
      "options": [
        "TypeScript classes extend ES6 classes by adding type annotations, access modifiers (public, private, protected), and enhanced type checking for improved type safety and object-oriented programming.",
        "TypeScript classes provide complete compile-time type transformation, converting class definitions into more performant functional programming constructs.",
        "TypeScript classes differ from ES6 classes by implementing a more complex inheritance model that supports multiple inheritance and advanced polymorphic behaviors.",
        "TypeScript classes are identical to ES6 classes but include additional runtime type checking mechanisms that validate object instances during execution."
      ],
      "correctIndex": 0,
      "explanation": "TypeScript enhances ES6 class syntax by introducing static type checking and access modifiers. This allows developers to define more robust and type-safe class structures with compile-time validation. The key differences include explicit type annotations and stronger encapsulation. Here's an example demonstrating TypeScript's class features:\n\n```typescript\nclass Person {\n  private name: string;\n  public constructor(name: string) {\n    this.name = name;\n  }\n}\n```"
    },
    {
      "id": 12,
      "question": "How do you implement _Inheritance_ in _TypeScript_?",
      "options": [
        "TypeScript supports inheritance exclusively through interface composition, where child classes reconstruct parent class methods using abstract base class definitions.",
        "In TypeScript, inheritance is implemented using the `extends` keyword, allowing a child class to inherit properties and methods from a parent class while maintaining type safety and supporting method overriding.",
        "Inheritance in TypeScript is achieved by using decorators and dependency injection to create hierarchical relationships between class-like structures.",
        "TypeScript implements inheritance through a complex prototype delegation mechanism that dynamically resolves method calls at runtime using advanced reflection techniques."
      ],
      "correctIndex": 1,
      "explanation": "Inheritance in TypeScript follows object-oriented programming principles, enabling code reuse and establishing hierarchical relationships between classes. The `extends` keyword allows a derived class to inherit and potentially override methods from its parent. Here's a practical example:\n\n```typescript\nclass Animal {\n  protected name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\nclass Dog extends Animal {\n  bark() {\n    console.log(`${this.name} barks!`);\n  }\n}\n```"
    },
    {
      "id": 13,
      "question": "What are _access modifiers_ and how do they work in _TypeScript_?",
      "options": [
        "Access modifiers represent type-level constraints that restrict how class members can be inherited and transformed during compilation, creating strict architectural boundaries.",
        "Access modifiers in TypeScript control the visibility and accessibility of class members, with public, protected, and private being the three primary types that determine where class properties and methods can be accessed.",
        "Access modifiers define meta-information for class members that enable dependency injection and runtime type checking in TypeScript object hierarchies.",
        "Access modifiers are TypeScript compiler directives that determine runtime behavior of class interactions, allowing dynamic control over object method execution and property manipulation."
      ],
      "correctIndex": 1,
      "explanation": "Access modifiers provide encapsulation in TypeScript classes by controlling member visibility. Public members are accessible everywhere, protected members within the class and its descendants, and private members only within the declaring class. They help enforce object-oriented design principles and prevent unauthorized access to internal class implementations."
    },
    {
      "id": 14,
      "question": "Discuss _Abstract classes_ and their purposes in _TypeScript_.",
      "options": [
        "Abstract classes function as design-time contracts that enforce strict typing rules and generate additional runtime type checking mechanisms.",
        "Abstract classes represent intermediate compilation targets that generate runtime polymorphic structures for dynamic type resolution in TypeScript's type system.",
        "Abstract classes in TypeScript are base classes that cannot be directly instantiated and are designed to be inherited by other classes, providing a blueprint for implementation with optional method signatures and concrete method definitions.",
        "Abstract classes are specialized interface implementations that enable advanced metaprogramming techniques by generating compile-time type constraints."
      ],
      "correctIndex": 2,
      "explanation": "Abstract classes serve as foundational structures in TypeScript's object-oriented programming model. They allow developers to define common behaviors and structures that derived classes must implement, providing a way to create partially implemented classes that guide inheritance and ensure consistent class structures."
    },
    {
      "id": 15,
      "question": "Can you describe the use of _Constructors_ within _TypeScript classes_?",
      "options": [
        "Constructors function as specialized factory methods that transform type definitions into executable object creation protocols during compilation.",
        "Constructors represent compile-time type resolution mechanisms that generate runtime object initialization strategies with dynamic parameter binding.",
        "Constructors in TypeScript are special methods used to initialize new object instances, automatically called when an object is created, and can set initial property values, apply access modifiers, and perform setup logic for class instances.",
        "Constructors are TypeScript's meta-programming interfaces that enable advanced object creation patterns through dependency injection and type inference."
      ],
      "correctIndex": 2,
      "explanation": "Constructors are crucial for object initialization in TypeScript classes. They provide a dedicated method for setting up new instances, allowing developers to define initial states, perform validation, and prepare objects with necessary configuration. TypeScript supports parameter properties, making constructor definitions more concise and powerful."
    }
  ],
  "processedAt": "2025-12-18T10:38:43.813Z"
}