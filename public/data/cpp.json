{
  "id": "cpp",
  "name": "C++",
  "slug": "cpp-interview-questions",
  "category": "Languages",
  "totalQuestions": 15,
  "topics": [
    "advanced",
    "async",
    "basics",
    "performance",
    "testing"
  ],
  "questions": [
    {
      "id": 1,
      "question": "What are the main _features_ of _C++_?",
      "options": [
        "C++ is a multi-paradigm programming language that extends C with object-oriented, generic, and functional programming features, offering enhanced type safety, memory management, and abstraction capabilities.",
        "C++ is a low-level systems programming language primarily designed for embedded systems and hardware interaction, focusing on direct memory manipulation and performance optimization.",
        "C++ is a pure object-oriented language that completely replaces traditional procedural programming models, emphasizing strict class-based design and runtime polymorphism.",
        "C++ is a modern scripting language that prioritizes rapid development and dynamic typing, with extensive support for web and mobile application development frameworks."
      ],
      "correctIndex": 0,
      "explanation": "C++ was developed by Bjarne Stroustrup in 1979 as an extension of C, introducing object-oriented programming concepts while maintaining compatibility with C. It provides powerful features like classes, templates, and smart pointers that enable more sophisticated and safer programming techniques. Unlike pure object-oriented languages, C++ supports multiple programming paradigms, giving developers flexibility in their design approach.\n\nExample of C++ features:\n```cpp\nclass Vector {\nprivate:\n    std::vector<int> data;\npublic:\n    void add(int value) { data.push_back(value); }\n};\n```"
    },
    {
      "id": 2,
      "question": "Explain the _difference_ between _C_ and _C++_.",
      "options": [
        "C and C++ are essentially the same language, with C++ being a minor syntactic variation that provides no significant additional programming capabilities or paradigm shifts.",
        "The primary difference between C and C++ is that C++ extends C with object-oriented programming features, enhanced type checking, templates, and standard library support, while C remains a procedural programming language.",
        "The main difference between C and C++ is that C++ is exclusively used for high-performance computing, while C is limited to embedded systems and operating system development.",
        "C++ is a completely rewritten language that eliminates all C language constructs, introducing an entirely new programming model with no backward compatibility."
      ],
      "correctIndex": 1,
      "explanation": "While C and C++ share syntactic similarities, C++ introduces significant programming paradigm enhancements. C++ supports object-oriented programming, generic programming through templates, and provides a more robust standard library. The language adds features like classes, inheritance, function overloading, and memory management techniques that are not present in traditional C.\n\nExample of C++ feature not in C:\n```cpp\nclass Shape {\npublic:\n    virtual double area() = 0;\n};\n\nclass Circle : public Shape {\n    double radius;\npublic:\n    double area() override { return 3.14 * radius * radius; }\n};\n```"
    },
    {
      "id": 3,
      "question": "What is _object-oriented programming_ in _C++_?",
      "options": [
        "Object-oriented programming in C++ is a programming paradigm that structures code around classes and objects, enabling encapsulation, inheritance, and polymorphism to create modular, reusable, and extensible software designs.",
        "Object-oriented programming in C++ is primarily a theoretical concept with limited practical application, serving more as an academic programming model than a pragmatic development approach.",
        "Object-oriented programming represents a method of writing code that completely eliminates procedural programming techniques, forcing all interactions through rigid class structures.",
        "Object-oriented programming in C++ is a design approach that exclusively focuses on creating complex class hierarchies with minimal consideration for actual program functionality or performance."
      ],
      "correctIndex": 0,
      "explanation": "Object-oriented programming allows developers to model real-world entities as software objects with both data and behavior. In C++, this is achieved through classes that can define data members, methods, access specifiers, and support inheritance. The four main principles are encapsulation, inheritance, polymorphism, and abstraction.\n\nExample demonstrating OOP principles:\n```cpp\nclass BankAccount {\nprivate:\n    double balance;\npublic:\n    void deposit(double amount) { balance += amount; }\n    bool withdraw(double amount) { \n        if (amount <= balance) {\n            balance -= amount;\n            return true;\n        }\n        return false;\n    }\n};\n```"
    },
    {
      "id": 4,
      "question": "What are the _access specifiers_ in _C++_ and what do they do?",
      "options": [
        "Access specifiers are keywords in C++ that control the visibility and accessibility of class members, with public, private, and protected levels determining how members can be accessed from different parts of the program.",
        "Access specifiers are compiler directives that manage memory allocation for class members, determining how data is stored and retrieved during program execution.",
        "Access specifiers are special functions in C++ that automatically regulate object interactions, creating a layer of security between different class implementations.",
        "Access specifiers are built-in runtime mechanisms that dynamically control object permissions and method invocation based on current program context."
      ],
      "correctIndex": 0,
      "explanation": "Access specifiers are a crucial part of object-oriented programming in C++, enabling encapsulation and data hiding. They define the accessibility of class members, protecting internal data and controlling how external code can interact with a class. The three access specifiers provide different levels of visibility: public members are accessible from anywhere, private members are only accessible within the class, and protected members are accessible within the class and its derived classes.\n\n```cpp\nclass Example {\npublic:\n    int publicValue;     // Accessible everywhere\nprivate:\n    int privateValue;   // Accessible only inside this class\nprotected:\n    int protectedValue; // Accessible in this class and derived classes\n};\n```"
    },
    {
      "id": 5,
      "question": "Explain the concept of _namespaces_ in _C++_.",
      "options": [
        "Namespaces are memory management techniques in C++ that dynamically allocate storage for related code segments, optimizing runtime performance and memory usage.",
        "Namespaces in C++ are a mechanism for organizing code into logical groups and preventing naming conflicts by creating separate scopes for identifiers, allowing developers to avoid name collisions in large projects.",
        "Namespaces are runtime environments that create isolated execution contexts for different parts of a program, enhancing modularity and security.",
        "Namespaces are compiler-level abstractions that provide advanced type checking and automatic code generation for complex software architectures."
      ],
      "correctIndex": 1,
      "explanation": "Namespaces provide a way to group related code elements under a unique identifier, preventing naming conflicts between different libraries or code modules. They allow multiple definitions of identifiers with the same name in different namespaces. Developers can access namespace elements using the scope resolution operator (::) or the 'using' directive.\n\n```cpp\nnamespace Math {\n    double calculate(double x, double y) { return x * y; }\n}\n\nnamespace Physics {\n    double calculate(double mass, double acceleration) { return mass * acceleration; }\n}\n\n// Can use fully qualified names without conflict\nDouble result = Math::calculate(5.0, 2.0);\n```"
    },
    {
      "id": 6,
      "question": "What is the _difference_ between '_struct_' and '_class_' in _C++_?",
      "options": [
        "Structs and classes are distinguished by their compilation model, with structs processed as lightweight data structures and classes treated as complex object templates.",
        "Structs are legacy data containers with limited functionality, while classes represent fully featured object-oriented constructs with advanced inheritance capabilities.",
        "Structs and classes in C++ represent different memory allocation strategies, with structs optimized for stack storage and classes designed for heap-based object management.",
        "In C++, structs and classes are both user-defined types, but differ primarily in their default member access levels: structs have public members by default, while classes have private members by default."
      ],
      "correctIndex": 3,
      "explanation": "While structs and classes in C++ are fundamentally similar, their default behaviors differ. The primary distinction is the default access level: struct members are public by default, making them suitable for simple data aggregation, while class members are private by default, promoting better encapsulation. Beyond this, they support the same features like methods, constructors, and inheritance.\n\n```cpp\nstruct SimpleData {\n    int x;  // Public by default\n    int y;  // Public by default\n};\n\nclass ComplexData {\n    int x;  // Private by default\n    int y;  // Private by default\npublic:\n    void setValues(int a, int b) { x = a; y = b; }\n};\n```"
    },
    {
      "id": 7,
      "question": "What is a _constructor_ and what are its _types_ in _C++_?",
      "options": [
        "A constructor is a global function that creates memory allocation for objects and determines their initial memory layout at compile time.",
        "A constructor is a special member function in C++ that initializes object instances automatically when an object is created. It shares the same name as the class and has no return type.",
        "A constructor is a private method responsible for validating object parameters and preventing unintended class instantiation.",
        "A constructor is a static method that prepares class templates for object generation and manages memory optimization strategies."
      ],
      "correctIndex": 1,
      "explanation": "Constructors play a crucial role in object initialization by setting initial values for object members. They are automatically called when an object is created and can have different forms like default, parameterized, or copy constructors. A constructor has the same name as its class and does not have a return type.\n\nExample of a constructor:\n```cpp\nclass Student {\npublic:\n    Student(string name, int age) {\n        this->name = name;\n        this->age = age;\n    }\nprivate:\n    string name;\n    int age;\n};\n```"
    },
    {
      "id": 8,
      "question": "Explain the concept of _destructors_ in _C++_.",
      "options": [
        "A destructor is a private method that validates object references before removing them from memory management.",
        "A destructor is a static method that manages object memory allocation and prevents memory leaks during program execution.",
        "A destructor is a compiler-generated function that ensures object state consistency before object termination.",
        "A destructor is a special member function automatically called when an object is destroyed, responsible for releasing dynamically allocated resources and performing necessary cleanup operations."
      ],
      "correctIndex": 3,
      "explanation": "Destructors are critical for proper memory management and resource deallocation. They are invoked automatically when an object goes out of scope or is explicitly deleted. A destructor is defined with a tilde (~) before the class name and has no parameters or return type.\n\nExample of a destructor:\n```cpp\nclass ResourceManager {\npublic:\n    ~ResourceManager() {\n        // Release dynamically allocated resources\n        delete[] dynamicArray;\n    }\nprivate:\n    int* dynamicArray;\n};\n```"
    },
    {
      "id": 9,
      "question": "What is _function overloading_ in _C++_?",
      "options": [
        "Function overloading is a method of creating polymorphic function interfaces that resolve parameter types during compilation.",
        "Function overloading is a mechanism for creating template functions that dynamically adapt their behavior based on runtime type inference.",
        "Function overloading is a compile-time technique for generating multiple function variants with predefined type transformations.",
        "Function overloading allows multiple functions with the same name but different parameter lists to coexist in a class, enabling the compiler to distinguish between them based on parameter types, count, and order."
      ],
      "correctIndex": 3,
      "explanation": "Function overloading provides flexibility in defining multiple functions with identical names but different parameter signatures. The compiler resolves which function to call based on the arguments passed during invocation.\n\nExample of function overloading:\n```cpp\nclass Calculator {\npublic:\n    int add(int a, int b) { return a + b; }\n    double add(double a, double b) { return a + b; }\n    int add(int a, int b, int c) { return a + b + c; }\n};\n```"
    },
    {
      "id": 10,
      "question": "What is _operator overloading_ in _C++_?",
      "options": [
        "Operator overloading in C++ allows developers to define custom behaviors for operators when used with user-defined types like classes and structures, enabling more intuitive and expressive code.",
        "Operator overloading is a feature that allows runtime modification of standard operator behaviors through dynamic method dispatch and template specialization in C++ class hierarchies.",
        "Operator overloading is a preprocessor directive in C++ that automatically converts built-in operators to custom function calls for improved memory management and type safety.",
        "Operator overloading provides a mechanism for compile-time type checking and transformation of standard operators to implement advanced metaprogramming techniques in object-oriented design."
      ],
      "correctIndex": 0,
      "explanation": "Operator overloading lets programmers define how operators work with custom types, essentially allowing classes to behave like built-in types. This is achieved by defining special member functions or global functions that specify the operator's behavior. For example, you can overload the '+' operator for a custom complex number class to define addition between two complex number objects.\n\n```cpp\nclass Complex {\npublic:\n    Complex operator+(const Complex& other) {\n        return Complex(real + other.real, imag + other.imag);\n    }\n};\n```"
    },
    {
      "id": 11,
      "question": "What is _dynamic memory allocation_ in _C++_?",
      "options": [
        "Dynamic memory allocation is a process of creating temporary memory segments that can be automatically recycled and managed by the operating system's memory management unit.",
        "Dynamic memory allocation is a memory management technique that automatically reallocates stack memory based on runtime computational requirements and scope constraints.",
        "Dynamic memory allocation provides a mechanism for compilers to optimize memory usage by dynamically redistributing memory resources during program compilation and linking.",
        "Dynamic memory allocation in C++ allows for runtime memory management by allocating memory from the heap, enabling flexible object creation and lifetime control during program execution."
      ],
      "correctIndex": 3,
      "explanation": "Dynamic memory allocation allows programs to request memory at runtime using operators like 'new' and functions like 'malloc()'. Unlike stack memory, which is fixed and automatically managed, heap memory can be explicitly allocated and deallocated by the programmer.\n\n```cpp\nint* dynamicArray = new int[10];  // Allocate memory for 10 integers\ndelete[] dynamicArray;  // Properly deallocate the memory\n```"
    },
    {
      "id": 12,
      "question": "Explain the _difference_ between '_new_' and '_malloc()_'.",
      "options": [
        "'new' is a legacy memory allocation function from C that performs low-level memory requests, while 'malloc()' represents the advanced object-oriented memory management approach.",
        "'malloc()' is a modern C++ memory allocation mechanism that provides enhanced type safety and automatic memory management through compile-time template resolution.",
        "'new' is a C++ language operator that allocates memory and constructs objects, while 'malloc()' is a C library function that simply allocates raw memory without calling constructors.",
        "'new' and 'malloc()' are identical memory allocation methods that can be used interchangeably in both C and C++ for managing dynamic memory across different compilation environments."
      ],
      "correctIndex": 2,
      "explanation": "The key differences between 'new' and 'malloc()' include type safety, object construction, and language origin. 'new' is type-safe, calls constructors, and is specific to C++, while 'malloc()' returns a void pointer and requires manual casting and constructor calls.\n\n```cpp\nint* p1 = new int(42);     // C++ style: allocates and constructs\nint* p2 = (int*)malloc(sizeof(int));  // C style: raw memory allocation\n```"
    },
    {
      "id": 13,
      "question": "What is a _memory leak_ and how can it be prevented?",
      "options": [
        "Memory leaks happen when a program's cache becomes fragmented, preventing efficient memory allocation and storage of temporary data.",
        "A memory leak occurs when dynamically allocated memory is not properly freed, causing the program to gradually consume more memory without releasing unused resources.",
        "A memory leak represents a situation where system memory becomes temporarily unavailable due to concurrent processing conflicts.",
        "A memory leak is a physical defect in computer hardware where memory chips gradually lose their ability to store data over time."
      ],
      "correctIndex": 1,
      "explanation": "Memory leaks typically occur in languages with manual memory management like C++. Developers can prevent them by carefully matching every memory allocation (new) with a corresponding deallocation (delete), using smart pointers like std::unique_ptr or std::shared_ptr, and following RAII (Resource Acquisition Is Initialization) principles.\n\nExample of potential memory leak:\n```cpp\nvoid potentialLeak() {\n    int* data = new int[100];  // Allocated memory\n    // Function ends without deleting data\n}\n```\n\nCorrect approach:\n```cpp\nvoid noLeak() {\n    std::unique_ptr<int[]> data(new int[100]);  // Automatic memory management\n}"
    },
    {
      "id": 14,
      "question": "What is a _dangling pointer_?",
      "options": [
        "A dangling pointer is a pointer that references memory that has been deallocated or is no longer valid, potentially causing undefined behavior when accessed.",
        "Dangling pointers represent memory segments that are incompletely initialized and cannot be safely dereferenced during program execution.",
        "A dangling pointer occurs when a pointer's memory address becomes fragmented and cannot maintain consistent reference to its original data.",
        "A dangling pointer is a pointer that temporarily loses connection to its original memory location during complex memory reallocations."
      ],
      "correctIndex": 0,
      "explanation": "Dangling pointers are dangerous because they can lead to unpredictable program behavior, crashes, or security vulnerabilities. They often occur when a pointer continues to reference memory after that memory has been freed or when the object it points to goes out of scope.\n\nExample of creating a dangling pointer:\n```cpp\nint* createDanglingPointer() {\n    int localVariable = 42;\n    return &localVariable;  // Returning address of local variable\n}\n```\n\nThis function returns a pointer to a local variable that will be destroyed when the function exits, creating a dangling pointer."
    },
    {
      "id": 15,
      "question": "Explain the concept of _smart pointers_ in _C++_.",
      "options": [
        "Smart pointers are C++ objects that manage dynamic memory automatically, providing safer and more convenient memory management by handling allocation and deallocation.",
        "Smart pointers represent advanced memory mapping strategies that allow programs to virtualize memory access more efficiently.",
        "Smart pointers are specialized memory optimization techniques that dynamically reroute memory allocation across different system resources.",
        "Smart pointers are compiler-level memory management constructs that predict and preemptively allocate memory based on program execution patterns."
      ],
      "correctIndex": 0,
      "explanation": "Smart pointers like std::unique_ptr, std::shared_ptr, and std::weak_ptr help prevent common memory management errors such as memory leaks and dangling pointers. They implement reference counting or ownership semantics to automatically manage memory lifecycle.\n\nExample of smart pointer usage:\n```cpp\nstd::unique_ptr<int> smartPtr(new int(42));\n// Memory automatically freed when smartPtr goes out of scope\n\nstd::shared_ptr<MyClass> sharedObject = std::make_shared<MyClass>();\n// Reference counted, memory freed when no references remain\n```\n\nThese smart pointers ensure proper memory management without manual deletion."
    }
  ],
  "processedAt": "2025-12-18T09:03:01.118Z"
}