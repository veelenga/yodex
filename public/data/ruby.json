{
  "id": "ruby",
  "name": "Ruby",
  "slug": "ruby-interview-questions",
  "category": "Languages",
  "totalQuestions": 12,
  "topics": [
    "advanced",
    "basics",
    "performance",
    "testing"
  ],
  "questions": [
    {
      "id": 1,
      "question": "What is _Ruby_, and why is it popular for web development?",
      "options": [
        "Ruby is a low-level systems programming language primarily used for embedded systems and hardware interactions, offering granular control over computer resources.",
        "Ruby is a dynamic, object-oriented programming language renowned for its elegant syntax and developer productivity, particularly through the Ruby on Rails web framework which revolutionized web application development.",
        "Ruby is a compiled programming language designed specifically for enterprise software development, known for its complex syntax and rigorous type checking system.",
        "Ruby is a functional programming language focused on mathematical computations and scientific computing, with strong emphasis on immutable data structures."
      ],
      "correctIndex": 1,
      "explanation": "Ruby was created by Yukihiro Matsumoto in 1995 with the philosophy of making programming enjoyable and productive. Its dynamic typing, object-oriented nature, and clean syntax allow developers to write expressive code quickly. The Ruby on Rails framework, created by David Heinemeier Hansson, significantly popularized Ruby by providing a robust, convention-over-configuration approach to web development.\n\nExample of Ruby's elegant syntax:\n```ruby\n# Ruby method definition\ndef greet(name)\n  \"Hello, #{name}!\"\nend\n\nputs greet('Developer')  # Outputs: Hello, Developer!\n```"
    },
    {
      "id": 2,
      "question": "How do you create a _Ruby script file_ and execute it on a _command line_?",
      "options": [
        "To create and execute a Ruby script, compile the code using a Ruby compiler, generate a binary executable, and then run the compiled program through a special runtime environment.",
        "To create and execute a Ruby script, you must first register the script with a Ruby development server and then deploy it through a specialized web interface.",
        "To create and execute a Ruby script, write the code in an integrated development environment and use a graphical runner that translates Ruby into machine instructions.",
        "To create and execute a Ruby script, save your code in a .rb file and use the 'ruby' command followed by the filename in the command line, which will interpret and run the script."
      ],
      "correctIndex": 3,
      "explanation": "Ruby scripts are text files with .rb extensions that can be directly executed by the Ruby interpreter. The ruby command reads and immediately executes the script without a separate compilation step. This interpreted nature allows for quick development and testing.\n\nExample of creating and running a script:\n```ruby\n# my_script.rb\nputs \"Welcome to Ruby!\"\n\n# Command line execution\n# $ ruby my_script.rb\n```"
    },
    {
      "id": 3,
      "question": "What are the basic _data types_ in _Ruby_?",
      "options": [
        "Ruby's data types are primarily focused on functional programming paradigms, with complex algebraic data types and pattern matching as its primary type system.",
        "Ruby features several core data types including integers (of arbitrary size), floating-point numbers, booleans (true/false), symbols, and treats everything as an object with methods and properties.",
        "Ruby implements a unique data type system where all values are references to complex object graphs, requiring explicit memory management and type conversion.",
        "Ruby uses strictly typed numeric data types with fixed memory allocations, supporting only 32-bit integers and double-precision floating-point numbers with explicit type declarations."
      ],
      "correctIndex": 1,
      "explanation": "Ruby's flexible type system allows dynamic typing and treats everything as an object. This means even primitive types like integers have methods and can be extended. Symbols are unique, immutable identifiers often used as hash keys for efficient lookups.\n\nExample demonstrating Ruby's type flexibility:\n```ruby\n# Integers can be of arbitrary size\nbig_number = 123456789012345678901234567890\n\n# Methods on primitive types\nputs 42.even?  # true\nputs :symbol.class  # Symbol\n```"
    },
    {
      "id": 4,
      "question": "Explain the difference between _symbols_ and _strings_ in _Ruby_.",
      "options": [
        "Ruby symbols are mutable string-like objects that can be modified and are primarily used for creating lightweight, reusable text identifiers with minimal memory overhead and quick comparisons.",
        "Symbols in Ruby are complex object types that represent dynamic text transformations, allowing for more flexible string manipulation compared to standard string objects with enhanced memory management capabilities.",
        "In Ruby, symbols are immutable, unique identifiers stored once in memory, while strings are mutable text objects that can be changed and duplicated. Symbols are typically used as hash keys or for efficiency, whereas strings are used for text manipulation and dynamic content.",
        "Symbols and strings in Ruby are essentially the same, with symbols being a specialized version of strings used for performance optimization in specific scenarios like method naming and internal object references."
      ],
      "correctIndex": 2,
      "explanation": "Symbols in Ruby are unique, immutable identifiers that are stored only once in memory, making them more memory-efficient and faster for lookups compared to strings. They are typically used as hash keys, method names, or in situations where you need a constant, unchangeable identifier. While strings can be modified and take up new memory with each creation, symbols remain constant and are referenced by the same memory address.\n\nHere's an example demonstrating symbol characteristics:\n```ruby\n# Symbol creation and comparison\nhash = { :name => 'Alice', :age => 30 }\nputs hash[:name]  # Efficient lookup\n\n# Compare object IDs to show uniqueness\nputs :example.object_id == :example.object_id  # true\nputs 'example'.object_id == 'example'.object_id  # false\n```"
    },
    {
      "id": 5,
      "question": "How are _constants_ declared and what is their _scope_ in _Ruby_?",
      "options": [
        "Ruby constants are dynamically scoped variables that can be redefined at runtime without restrictions, providing flexible global state management across different program contexts.",
        "Constants in Ruby are strictly immutable global variables that cannot be modified under any circumstances and are automatically frozen when declared to prevent any potential changes.",
        "Constants in Ruby are special class-level variables that are inherited by subclasses and can only be defined within class or module definitions, with strict access control mechanisms.",
        "In Ruby, constants are declared using uppercase letters and are lexically scoped, meaning their visibility is determined by where they are defined. While technically reassignable, changing a constant's value triggers a warning and is considered bad practice."
      ],
      "correctIndex": 3,
      "explanation": "Constants in Ruby provide a way to define values that are meant to remain stable throughout a program's execution. They are typically used for configuration values, configuration settings, or any values that should not change. While technically reassignable, doing so generates a warning, signaling potential misuse.\n\nHere's an example of constant declaration and usage:\n```ruby\n# Constant declaration\nMAX_USERS = 100\nCONFIG = { database: 'production', timeout: 30 }\n\n# Class-level constant\nclass UserManager\n  MAX_CONNECTIONS = 50\nend\n```"
    },
    {
      "id": 6,
      "question": "Explain the use of '_require_' and '_include_' in _Ruby_.",
      "options": [
        "In Ruby, 'require' is a low-level file system method for accessing external resources, and 'include' is a high-level metaprogramming technique for dynamically extending class capabilities.",
        "Ruby's 'require' and 'include' are interchangeable methods for importing external code, with 'require' primarily used for adding module functionality and 'include' for loading library files.",
        "In Ruby, 'require' is used to load external libraries and files, ensuring they are loaded only once per program execution, while 'include' is used to mix module methods into a class's instance methods.",
        "The 'require' method in Ruby dynamically generates new classes at runtime, while 'include' provides a mechanism for creating temporary code references across different modules."
      ],
      "correctIndex": 2,
      "explanation": "The 'require' method in Ruby is crucial for loading external libraries and files, preventing multiple loads of the same library. It searches the Ruby load path and ensures that a file is loaded only once during program execution. In contrast, 'include' is used to mix module methods into a class, allowing for horizontal code reuse and composition.\n\nHere's an example demonstrating their usage:\n```ruby\n# Requiring an external library\nrequire 'json'\n\n# Including a module in a class\nmodule Printable\n  def print_details\n    puts 'Printing details...'\n  end\nend\n\nclass User\n  include Printable\nend\n\nuser = User.new\nuser.print_details  # Module method now available\n```"
    },
    {
      "id": 7,
      "question": "What are _Ruby iterators_ and how do they work?",
      "options": [
        "Ruby iterators represent a design pattern where collection elements are processed through a complex callback mechanism, allowing advanced functional programming techniques with significant memory overhead.",
        "Ruby iterators are specialized loops that require explicit index management and provide minimal performance benefits for data processing. They are primarily used for basic sequential traversal of linear collections.",
        "Ruby iterators are methods that traverse through collections, allowing developers to perform operations on each element without explicitly managing loop counters. They provide a clean, functional approach to data manipulation across various data structures like arrays, ranges, and hashes.",
        "Iterators in Ruby are advanced control structures that automatically compile collection processing into lower-level machine code, enabling highly optimized data transformation with minimal developer intervention."
      ],
      "correctIndex": 2,
      "explanation": "Iterators in Ruby are powerful methods that simplify collection traversal. The most common iterator is 'each', which allows seamless element processing without manual loop management. Ruby's iterator methods are part of its functional programming capabilities, enabling concise and readable code. Here's a typical example of using an iterator:"
    },
    {
      "id": 8,
      "question": "How are _errors_ handled in _Ruby_?",
      "options": [
        "Ruby's error management relies on a complex middleware system that automatically translates system-level exceptions into user-friendly messages without requiring explicit error catching strategies.",
        "Error handling in Ruby is implemented through a meta-programming approach where runtime errors are dynamically transformed and rerouted based on predefined configuration parameters.",
        "Ruby handles errors through an exception hierarchy where developers can catch and manage different types of errors using begin-rescue blocks, allowing for graceful error handling and preventing program termination.",
        "Error handling in Ruby is primarily managed through global error tracking mechanisms that intercept runtime exceptions and redirect them to a centralized logging system with minimal developer intervention."
      ],
      "correctIndex": 2,
      "explanation": "Ruby's exception handling provides a robust mechanism for managing runtime errors. The begin-rescue-end structure allows developers to catch specific or generic exceptions, providing fine-grained control over error management. Developers can specify exact error types or use broader exception classes."
    },
    {
      "id": 9,
      "question": "Describe the difference between _local_, _instance_, and _class variables_.",
      "options": [
        "Variable types in Ruby are determined by complex inheritance patterns, where local variables represent static contexts, instance variables reflect object state, and class variables manage metaprogramming capabilities.",
        "In Ruby, local variables have block-level scope, instance variables are specific to object instances and prefixed with '@', and class variables shared across all instances of a class are prefixed with '@@'.",
        "Ruby's variable system uses a hierarchical resolution mechanism where local variables represent compilation-time constants, instance variables track object lifecycle, and class variables enable dynamic type inference.",
        "Ruby variables are distinguished by their scope enforcement, with local variables being globally accessible, instance variables restricted to method calls, and class variables dynamically reassigned during runtime."
      ],
      "correctIndex": 1,
      "explanation": "Ruby's variable scoping is crucial for understanding object-oriented and functional programming paradigms. Local variables are limited to their immediate scope, instance variables persist within object instances, and class variables are shared across all instances of a class."
    },
    {
      "id": 10,
      "question": "What are _Ruby's accessor methods_?",
      "options": [
        "Accessor methods in Ruby are metaprogramming techniques that dynamically create method wrappers around object properties, allowing controlled internal state management.",
        "Ruby's accessor methods are compilation-time directives that generate runtime method proxies for intercepting and managing object attribute interactions.",
        "Ruby's accessor methods are predefined class-level methods that automatically generate instance variables with specific naming conventions for object-oriented programming design patterns.",
        "Ruby's accessor methods are special methods that control attribute access: attr_reader generates a getter, attr_writer creates a setter, and attr_accessor provides both reading and writing capabilities for object attributes."
      ],
      "correctIndex": 3,
      "explanation": "Accessor methods in Ruby provide a convenient way to define attribute access without manually writing getter and setter methods. They reduce boilerplate code and provide a standard mechanism for managing object attributes. The three types (attr_reader, attr_writer, attr_accessor) offer different levels of attribute manipulation."
    },
    {
      "id": 11,
      "question": "How does _garbage collection_ work in _Ruby_?",
      "options": [
        "The Ruby garbage collector uses a generational approach that segments memory into young and old generations, prioritizing collection of recently created objects.",
        "Ruby's garbage collection uses a mark-and-sweep algorithm that identifies and reclaims unused memory by first marking all reachable objects from the root references, then sweeping and freeing unmarked memory.",
        "Ruby's memory management relies on a concurrent garbage collection strategy that runs parallel to the main application thread, minimizing performance interruptions.",
        "Ruby's garbage collection employs a reference counting mechanism that tracks object usage and immediately deallocates memory when reference counts drop to zero."
      ],
      "correctIndex": 1,
      "explanation": "Garbage collection in Ruby automatically manages memory allocation and deallocation. The mark-and-sweep approach ensures efficient memory management by identifying and removing unreferenced objects. Modern Ruby versions have sophisticated garbage collection algorithms that optimize memory usage and application performance."
    },
    {
      "id": 12,
      "question": "Explain the difference between '_gets.chomp_' and '_gets.strip_'.",
      "options": [
        "gets.chomp is a system-level input method that preserves whitespace, whereas gets.strip is a high-level string processing method for user input.",
        "gets.chomp and gets.strip are identical methods used for input sanitization, with no meaningful difference in their string manipulation behavior.",
        "gets.chomp removes only the trailing newline character, while gets.strip eliminates both leading and trailing whitespace, providing a more comprehensive input cleaning method.",
        "gets.chomp operates on console input streams, while gets.strip is primarily used for parsing formatted text files and removing peripheral whitespace."
      ],
      "correctIndex": 2,
      "explanation": "The primary difference between gets.chomp and gets.strip is their approach to whitespace removal. While gets.chomp focuses on newline character removal, gets.strip provides a more comprehensive whitespace cleaning solution for input processing."
    }
  ],
  "processedAt": "2025-12-18T10:20:40.579Z"
}