{
  "id": "data-structures",
  "name": "Data Structures",
  "slug": "data-structures-interview-questions",
  "category": "Data Structures",
  "totalQuestions": 15,
  "topics": [
    "advanced",
    "basics",
    "performance",
    "testing"
  ],
  "questions": [
    {
      "id": 1,
      "question": "Explain how you would reverse an array in place.",
      "options": [
        "Recursively swap elements from the middle outwards",
        "Create a new array and copy elements in reverse order",
        "Use a built-in reverse function without manually swapping",
        "In-place array reversal involves swapping elements from the start and end of the array, moving towards the center until the entire array is reversed."
      ],
      "correctIndex": 3,
      "explanation": "The in-place reversal technique modifies the original array without requiring additional memory. By using two pointers at the beginning and end of the array, elements are systematically swapped until the entire array is reversed. This method is memory-efficient and works for arrays of any size."
    },
    {
      "id": 2,
      "question": "What is the difference between an _array_ and a _linked list_?",
      "options": [
        "Arrays and linked lists are essentially the same data structure",
        "Linked lists always have faster access times than arrays",
        "Arrays are contiguous memory blocks with fixed size and direct index access, while linked lists are non-contiguous data structures with dynamic memory allocation and element connections through pointers.",
        "Arrays can dynamically resize like linked lists"
      ],
      "correctIndex": 2,
      "explanation": "The key distinction between arrays and linked lists lies in their memory organization and access patterns. Arrays provide constant-time random access and require contiguous memory, while linked lists offer dynamic memory allocation with sequential access through node connections. Each structure has unique advantages depending on the specific use case and performance requirements."
    },
    {
      "id": 3,
      "question": "How would you check for duplicates in an array without using extra space?",
      "options": [
        "To check for duplicates without extra space, use a nested loop that compares each element with every subsequent element in the array.",
        "Implement a binary search to find duplicates",
        "Sort the array first and then check adjacent elements",
        "Use a hash set to track unique elements"
      ],
      "correctIndex": 0,
      "explanation": "The brute force method for detecting duplicates involves comparing each element with every other element in the array. While this approach has a quadratic time complexity, it accomplishes the task without using additional memory. The technique systematically checks each element against all others to identify any repeated values."
    },
    {
      "id": 4,
      "question": "Can you explain how to perform a _binary search_ on a sorted array?",
      "options": [
        "Binary search can only be used on unsorted arrays with unique elements.",
        "Binary search requires scanning every element in the array sequentially.",
        "Binary search works by repeatedly dividing a sorted array in half, comparing the middle element with the target, and eliminating the half that cannot contain the target.",
        "Binary search works by randomly selecting elements until the target is found."
      ],
      "correctIndex": 2,
      "explanation": "Binary search is an efficient algorithm for finding an element in a sorted array. It leverages the sorted nature of the array to eliminate half of the remaining search space in each iteration. The algorithm compares the target value with the middle element and narrows down the search range, reducing time complexity to O(log n) compared to linear search's O(n)."
    },
    {
      "id": 5,
      "question": "How would you rotate a two-dimensional _array_ by 90 degrees?",
      "options": [
        "To rotate an array, you must manually swap each element's position using multiple nested loops.",
        "90-degree rotation can only be done by rotating each element individually around a central point.",
        "Rotating a 2D array requires creating a completely new matrix with copied elements.",
        "To rotate a 2D array 90 degrees, first transpose the matrix (swap elements across the main diagonal) and then reverse either the rows or columns depending on the rotation direction."
      ],
      "correctIndex": 3,
      "explanation": "Matrix rotation is an in-place transformation that efficiently changes the orientation of a 2D array. By first transposing the matrix (swapping rows and columns) and then reversing rows or columns, you can achieve a 90-degree rotation with minimal additional space. This method works for square matrices and maintains the original spatial relationships between elements."
    },
    {
      "id": 6,
      "question": "Describe an algorithm to compress a string such as \"_aabbccc_\" to \"_a2b2c3_\".",
      "options": [
        "String compression involves iterating through the string, counting consecutive character occurrences, and building a new string with characters followed by their count.",
        "Compression can only be done by removing duplicate characters completely.",
        "String compression requires converting each character to its ASCII value first.",
        "String compression works best when using a complex hashing algorithm."
      ],
      "correctIndex": 0,
      "explanation": "String compression is a technique to reduce string length by representing consecutive character runs with a character and its count. This method is particularly useful for strings with repeated characters, creating a more compact representation. The algorithm typically involves tracking the current character, maintaining a running count, and building a new compressed string as it iterates through the input."
    },
    {
      "id": 7,
      "question": "What is an _array slice_ and how is it implemented in programming languages?",
      "options": [
        "An array slice is a view or subset of an existing array that references a continuous section of the original array, allowing efficient data access and manipulation without copying the entire array.",
        "An array slice is a method of sorting array elements in ascending order.",
        "An array slice is a complete copy of an entire array with a new memory allocation.",
        "An array slice is a data structure that only contains unique elements from the original array."
      ],
      "correctIndex": 0,
      "explanation": "Array slices provide a lightweight way to work with portions of an existing array, referencing the same underlying memory. They are memory-efficient because they don't create a full copy of the data, instead creating a view that can be used to access or modify a segment of the original array. Languages like Python, Rust, and Go implement array slices as a powerful and performant way to handle array subsets."
    },
    {
      "id": 8,
      "question": "Can you discuss the _time complexity_ of _array insertion_ and _deletion_?",
      "options": [
        "Array operations are instantaneous and never require element movement.",
        "Insertion and deletion time complexity depends entirely on the array's initial size.",
        "Array insertion and deletion always have O(1) time complexity.",
        "Array insertion and deletion typically have O(n) time complexity because they often require shifting elements to maintain the array's structure, with some exceptions like appending to the end of the array."
      ],
      "correctIndex": 3,
      "explanation": "The time complexity of array operations is primarily influenced by the need to potentially shift elements. Inserting or deleting elements from the middle of an array requires moving subsequent elements, which results in a linear time complexity. Appending to the end of an array is typically constant time, but may involve dynamic resizing in some implementations. The computational cost increases with the array's size, making these operations less efficient for large data sets."
    },
    {
      "id": 9,
      "question": "What are some ways to merge two sorted _arrays_ into one sorted _array_?",
      "options": [
        "Merging two sorted arrays can be accomplished by using a two-pointer approach, comparing elements from both arrays and building a new sorted array in linear time complexity O(n+m).",
        "Sorted arrays can only be merged by converting them to sets first.",
        "Merging sorted arrays always requires sorting the entire combined array from scratch.",
        "Merging sorted arrays is impossible without using a complex sorting algorithm."
      ],
      "correctIndex": 0,
      "explanation": "The most efficient method of merging sorted arrays involves using two pointers to compare elements from each array, systematically building a new sorted array. This approach takes advantage of the arrays' existing sorted state, allowing for a single-pass merge with optimal time complexity. The technique is particularly useful in scenarios like merge sort and combining ordered data sets, providing a straightforward and performant solution to array merging."
    },
    {
      "id": 10,
      "question": "How do you find the _kth largest element_ in an unsorted _array_?",
      "options": [
        "Sort the entire array in descending order and return the kth index.",
        "Use a max heap to extract the kth largest element by repeatedly removing the maximum.",
        "To find the kth largest element in an unsorted array, use the Quickselect algorithm, which partitions the array and selectively searches the appropriate subarray to find the desired element.",
        "Iterate through the array k times, removing the largest element each iteration."
      ],
      "correctIndex": 2,
      "explanation": "The Quickselect algorithm is an efficient approach that leverages the partitioning technique from quicksort. By recursively dividing the array and focusing on the appropriate subarray, it can find the kth largest element with an average time complexity of O(n). The key is to strategically reduce the search space by eliminating unnecessary portions of the array."
    },
    {
      "id": 11,
      "question": "Explain how a _singly linked list_ differs from a _doubly linked list_.",
      "options": [
        "A singly linked list contains nodes that point only to the next node, while a doubly linked list has nodes with pointers to both the previous and next nodes, allowing bidirectional traversal.",
        "Doubly linked lists are always sorted, whereas singly linked lists are unordered.",
        "Singly linked lists can store more data per node, while doubly linked lists are more memory-efficient.",
        "Singly linked lists can only be traversed forward, but doubly linked lists can be traversed in both directions."
      ],
      "correctIndex": 0,
      "explanation": "The primary difference between singly and doubly linked lists is the node structure. Singly linked lists have a simpler implementation with a single pointer to the next node, making them memory-efficient but limiting traversal to one direction. Doubly linked lists provide more flexibility with bidirectional navigation but require additional memory to store the extra pointer."
    },
    {
      "id": 12,
      "question": "How would you detect a _cycle_ in a _linked list_?",
      "options": [
        "Count the number of nodes and compare it with the list's expected length.",
        "To detect a cycle in a linked list, use Floyd's Cycle Detection Algorithm (Tortoise and Hare), which employs two pointers moving at different speeds to identify if the list contains a cycle.",
        "Reverse the linked list and check if the original structure is maintained.",
        "Use a hash set to track visited nodes and check for duplicates."
      ],
      "correctIndex": 1,
      "explanation": "Floyd's Cycle Detection Algorithm is an elegant solution that uses two pointers moving at different speeds. The 'tortoise' moves one step at a time, while the 'hare' moves two steps. If a cycle exists, the pointers will eventually meet at the same node. This method is efficient, with O(n) time complexity and O(1) space complexity, making it superior to other cycle detection techniques."
    },
    {
      "id": 13,
      "question": "What are the major operations you can perform on a _linked list_, and their _time complexities_?",
      "options": [
        "Linked lists only support linear traversal with O(n) complexity for all operations",
        "Major linked list operations include insertion (O(1) at head/tail, O(n) at arbitrary position), deletion (O(1) at head/tail, O(n) at arbitrary position), and search (O(n)).",
        "Linked lists can be randomly accessed in O(1) time like arrays",
        "Linked lists have constant time O(1) complexity for all insert and delete operations"
      ],
      "correctIndex": 1,
      "explanation": "Linked lists provide flexible insertion and deletion with varied time complexities based on position. While head and tail operations are constant time, middle operations require traversing the list, resulting in linear O(n) complexity. Search operations also require scanning the entire list, making them O(n)."
    },
    {
      "id": 14,
      "question": "Can you describe an _in-place algorithm_ to reverse a _linked list_?",
      "options": [
        "To reverse a linked list in-place, iterate through the list, redirecting each node's next pointer to the previous node while tracking three key references: previous, current, and next nodes.",
        "In-place reversal is not possible with constant extra space",
        "In-place reversal requires creating a completely new linked list",
        "Reversing a linked list can only be done by copying all elements to a new data structure"
      ],
      "correctIndex": 0,
      "explanation": "In-place reversal modifies the original list structure by changing pointer references without requiring additional memory allocation. The algorithm manipulates existing node connections, ensuring O(1) space complexity and O(n) time complexity by traversing the list once."
    },
    {
      "id": 15,
      "question": "Explain how you would find the _middle element_ of a _linked list_ in one pass.",
      "options": [
        "The middle can only be found by traversing the list multiple times",
        "Finding the middle requires storing all elements in an auxiliary array",
        "You must count total list elements first, then traverse to the middle",
        "To find the middle element of a linked list in one pass, use the two-pointer technique with a slow pointer moving one step and a fast pointer moving two steps simultaneously."
      ],
      "correctIndex": 3,
      "explanation": "The two-pointer technique efficiently locates the middle element by leveraging different traversal speeds. When the fast pointer reaches the list's end, the slow pointer will be positioned at the middle, allowing a single-pass O(n) solution with O(1) extra space."
    }
  ],
  "processedAt": "2025-12-14T21:35:33.955Z"
}